<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Random Notes â€“ Crypto Blog</title><link>https://hhanh00.github.io/cryptoblog/docs/</link><description>Recent content in Crypto Blog on Random Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 18 Feb 2022 11:49:09 +0800</lastBuildDate><atom:link href="https://hhanh00.github.io/cryptoblog/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Finite Fields</title><link>https://hhanh00.github.io/cryptoblog/docs/crypto/ff/</link><pubDate>Sat, 12 Feb 2022 21:01:42 +0800</pubDate><guid>https://hhanh00.github.io/cryptoblog/docs/crypto/ff/</guid><description>
&lt;p>In one of the previous posts, we discussed finite sets: Sets with
a non infinite number of elements.&lt;/p>
&lt;p>We also talked about functions from sets to sets and a particular
type of function that is quite useful, the 1 to 1 functions.
They map each element from the source set to exactly unique one element of
the destination set and vice-versa.&lt;/p>
&lt;p>We can map any finite set to the set of integers from 0 to $n-1$,
where $n$ is the number of elements of the set. It can be done by
simply labeling elements as &amp;ldquo;first&amp;rdquo;, &amp;ldquo;second&amp;rdquo;, &amp;ldquo;third&amp;rdquo;, etc.&lt;/p>
&lt;p>From now on, we will only be interested in these finite sets: $N_p = [0, \dots, n-1]$&lt;/p>
&lt;p>In it, we can define the classic addition and multiplication. The only difference is that
since the result exceeds must be in the set, we subtract or add multiples of $n$ until it does.&lt;/p>
&lt;p>For example, if $n = 60$,&lt;/p>
&lt;p>\begin{align}
10 + 20 &amp;amp; = 30 \pmod{60} \\
45 + 15 &amp;amp; = 0 \pmod{60} \\
45 + 30 &amp;amp; = 15 \pmod{60} \\
45 + 45 &amp;amp; = 30 \pmod{60} \\
\end{align}&lt;/p>
&lt;p>The $\pmod{60}$ indicates that we are doing arithmetic &lt;strong>modulo&lt;/strong> 60.&lt;/p>
&lt;p>You probably have recognized the behavior of minutes in the hour.&lt;/p>
&lt;p>Multiplication works the same way:&lt;/p>
&lt;p>\begin{align}
5 \times 10 &amp;amp; = 50 \pmod{60} \\
10 \times 20 &amp;amp; = 20 \pmod{60} \\
\end{align}&lt;/p>
&lt;p>The last one is because $ 10 \times 20 = 200 = 180 + 20 = 60 \times 3 + 20 $. Multiples of 60 are discarded,
so the result is $20$.&lt;/p>
&lt;h2 id="groups">Groups&lt;/h2>
&lt;p>$N_p$ with the + operator, form an algebric group: $(N_p, +)$. Because together they have a set of properties:&lt;/p>
&lt;ul>
&lt;li>there is neutral element: $0$,&lt;/li>
&lt;li>$+$ is associative: $(a + b) + c = a + (b + c)$,&lt;/li>
&lt;li>every element has an opposite: $a + (-a) = (-a) + a = 0$&lt;/li>
&lt;/ul>
&lt;p>These properties come from the underlying $+$ (the one that works in $N$).
The only remaining property to have is that $ a + b $ belongs to $N_p$.&lt;/p>
&lt;h2 id="commutative-group">Commutative Group&lt;/h2>
&lt;p>If in $+$ also commutes, i.e, if $ a + b = b + a $, then $(N_p, +)$ is a commutative group.&lt;/p>
&lt;h2 id="sub-group">Sub-Group&lt;/h2>
&lt;p>$N_p$ can also contain groups that are made of elements of $N_p$. Such a group is called
a sub-group.&lt;/p>
&lt;p>It&amp;rsquo;s not always the case, but for instance can you find sub-groups of $N_{60}$ ?&lt;/p>
&lt;p>If instead of taking every element of $N_{60}$, we take only $0, 10, 20, 30, 40, 50$
we have a sub-group.&lt;/p>
&lt;p>The three properties above are clearly still met and we can also see that
whenever we add 2 of these numbers, the result is still among these numbers.&lt;/p>
&lt;p>Can you find more sub-groups?&lt;/p>
&lt;p>Yes, in fact any divider of 60 forms a sub-group: 2, 3, 4, 5, 6, 10, 12, 15, 20, 30.&lt;/p>
&lt;h2 id="fields">Fields&lt;/h2>
&lt;p>Let&amp;rsquo;s now consider the multiplication in combination with the addition.&lt;/p>
&lt;p>$(N_p, +, \times)$&lt;/p>
&lt;p>For this to be field,&lt;/p>
&lt;ul>
&lt;li>$(N_p, +)$ is a commutative group with neutral element $0$,&lt;/li>
&lt;li>$(N_p^*, \times)$ is a commutative group with neutral element $1$,&lt;/li>
&lt;li>$\times$ distributes over $+$: $(a + b) \times c = a \times c + b \times c$&lt;/li>
&lt;/ul>
&lt;p>Again, nothing very special &lt;strong>but&lt;/strong> this time $N_p$ is not always a field.
The problem is that the multiplicative inverse may not exist for every element of $N_p$.&lt;/p>
&lt;p>The smallest integer field is $F_2$ which only contains {0, 1}. $F_3$ is also a field.
$2$ is its own inverse.&lt;/p>
&lt;p>$$ 2 \times 2 = 4 = 1 \mod 3 $$&lt;/p>
&lt;p>$F_4$ and $F_5$ are fields too. But $N_6$ is not a field. Because $2$ has no inverse.&lt;/p>
&lt;p>\begin{align}
2 \times 1 &amp;amp;= 2\pmod 6 \\
2 \times 2 &amp;amp;= 4\pmod 6 \\
2 \times 3 &amp;amp;= 6 = 0\pmod 6 \\
2 \times 4 &amp;amp;= 8 = 2\pmod 6 \\
2 \times 5 &amp;amp;= 6 = 4\pmod 6 \\
\end{align}&lt;/p>
&lt;p>When the size of the set is even and $&amp;gt; 2$, ($2x \mod n)$ will be an even number for any value
of $x$. Therefore it cannot be equal to 1 and 2 has no inverse.&lt;/p>
&lt;p>In fact, $p$ must be a prime number or a power of a prime number.&lt;/p>
&lt;p>When $N_p$ is a field, the convention is to use the letter F: $F_p$.&lt;/p>
&lt;p>All the calculations in cryptography are performed in a finite field $F_p$.
$p$ is a very large prime number. For Bitcoin, $p$ is&lt;/p>
&lt;p>\begin{align}
p &amp;amp; = 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1 \\
&amp;amp; = 1157920892373161954235709850086879078
&amp;hellip;\\
&amp;amp; &amp;hellip;53269984665640564039457584007908834671663 \\
\end{align}&lt;/p></description></item><item><title>Docs: Zero Knowledge Proof Overview</title><link>https://hhanh00.github.io/cryptoblog/docs/zkp/zkp-overview/</link><pubDate>Thu, 10 Feb 2022 11:04:58 +0800</pubDate><guid>https://hhanh00.github.io/cryptoblog/docs/zkp/zkp-overview/</guid><description>
&lt;p>We are going to spend quite some time discussing crypto,
maths and computer science so it is worth taking some
time to put things in perspective.&lt;/p>
&lt;p>We are mostly interested in crypto currencies and
one of the main valuable properties is &lt;strong>decentralization&lt;/strong>.&lt;/p>
&lt;h2 id="decentralization">Decentralization&lt;/h2>
&lt;p>When the system is centralized, there is a main entity
that oversees the entire management and operation.
Users implicitly trust this entity since anyway they
are not in charge of anything and most likely don&amp;rsquo;t
have access to the records that would allow them to
perform any verification.&lt;/p>
&lt;p>However, if the system is decentralized, there are
several or potentially a very large number of entities
that together make sure the system operates properly.&lt;/p>
&lt;p>Moreover some system allow anyone to participate as
an management entity therefore they cannot be trusted
because noone is in the position of overseeing their
honesty.&lt;/p>
&lt;h2 id="enter-crypto">Enter Crypto&lt;/h2>
&lt;p>Enter cryptography. Before cryptocurrencies, it was
mostly about encrypting and decrypting messages
but there is another very important application of
cryptography: Authentication.&lt;/p>
&lt;p>And this was made possible with Public/Private Crypto.&lt;/p>
&lt;h3 id="publicprivate-crytpo">Public/Private Crytpo&lt;/h3>
&lt;p>In traditional crypto, you have a key, i.e. a secret
value that the sender and the receiver both know
but keep private.&lt;/p>
&lt;p>The same secret value is used for encrypting and
decrypting. It is called &lt;em>symetric&lt;/em> crypto.&lt;/p>
&lt;p>With public/private crypto or &lt;em>asymetric&lt;/em> crypto,
there are two keys: the secret key and the public key.&lt;/p>
&lt;p>The public key can be easily derived from the secret key
but the other way is impossible (or practially impossible
with current technology for decades).&lt;/p>
&lt;p>Messages are encrypted with the public key but they
can only be decrypted with the secret key. With this system,
the public key can be distributed so that the receiver
can get encrypted messages from anyone and yet be the
only person able to read them.&lt;/p>
&lt;p>That&amp;rsquo;s one of the application of public/private crypto.&lt;/p>
&lt;p>The other popular application is authentication. These
crypto system have the ability to be used in &amp;ldquo;reverse&amp;rdquo;:
Messages are encrypted with the secret key and
decrypted with the public key. One can prove his identity
but showing he/she knows the secret key that matches
a given public key. To do so, he/she encrypts a known
message with the secret key. When it gets decrypted
with the public key, we get back the original known message.
The actual process has more steps but in essence, making a &lt;em>digital
signature&lt;/em> can be boiled down to this technique.&lt;/p>
&lt;p>This is a zero knowledge proof.&lt;/p>
&lt;p>We &lt;strong>proved&lt;/strong> we know the secret key and therefore our identity,
while not revealing any information that could help other
parties discover the secret key.&lt;/p>
&lt;p>Cryptocurrencies are mainly using this form of cryptography
and very seldom the traditional encryption/decryption.&lt;/p>
&lt;p>This is because they tend to put the focus on being trustless
rather than privacy. When you want to be trustless, you want
to allow anyone to verify your claims. But also, you don&amp;rsquo;t
want to reveal your secrets. That&amp;rsquo;s why Zero Knowledge Proofs
are gaining more and more traction.&lt;/p>
&lt;h2 id="smart-contracts">Smart Contracts&lt;/h2>
&lt;p>Though authentication or signatures are quite useful and
are indeed in big part of the cryptocurrencies, i.e. Bitcoin
only uses digital signatures, there is a push towards extending
cryptocurrencies to more than tracking account balances.&lt;/p>
&lt;p>The first cryptocurrency that introduced &amp;ldquo;smart contracts&amp;rdquo; is
Ethereum. Smart contracts are general programs which are
executed by many computers. With Bitcoin, computers deal with
account transactions, which are a specific type of program.&lt;/p>
&lt;p>An account transaction transfers coins between sources and destinations.
Whereas a smart contract can be made to do more varied tasks.&lt;/p>
&lt;h2 id="sudoku-contract">Sudoku contract&lt;/h2>
&lt;p>Suppose you have a Eth smart contract that implements the rules of Sudoku.
A puzzle has a set of given digits and the smart contract
verifies that the submitted solution is correct.
If it is, the contract could unlock some funds and reward the account
that submitted the solution.&lt;/p>
&lt;p>All the computers in the Eth network perform the verification.
One of the core principle of a crypto currency system is that
all the participants agree on the same state: Either the solution is
correct and the funds are paid, or the solution is incorrect and the
solution is rejected.&lt;/p>
&lt;p>However, what if the person who found the solution does not want
to show it. Most likely, since we can&amp;rsquo;t simply trust his word that
he has a valid solution, he will not get paid.&lt;/p>
&lt;p>So it&amp;rsquo;s either:&lt;/p>
&lt;ul>
&lt;li>show me the solution and get paid, but then the solution is revealed
to the entire world,&lt;/li>
&lt;li>keep the solution but don&amp;rsquo;t get paid&lt;/li>
&lt;/ul>
&lt;h2 id="zero-knowledge-proofs">Zero Knowledge Proofs&lt;/h2>
&lt;p>Zero Knowledge Proofs allow someone to prove that he has a solution
without revealing it.&lt;/p>
&lt;p>In this hypothetical case, the verifiers are not interested in the solution itself.
It is very similar to the authentication scenario from earlier where
we wanted to show that we have the secret key without revealing it.&lt;/p>
&lt;p>But in this case, this is not an arbitrary key but something that solves
a specific problem.&lt;/p>
&lt;p>The beauty of ZKP is that they can be made to show that you have the
solution to a complex problem, without showing that solution.&lt;/p>
&lt;p>It could be because the solution has private information, or it
could also be that the solution is very large.&lt;/p>
&lt;h2 id="caveats">Caveats&lt;/h2>
&lt;p>ZKP are fairly new in cryptography and therefore still under a lot of research
and development. In my opinion, we are experiencing the very early days, kind like the 60s
were for computers. Though the theory of computer science did not evolve
significantly, today&amp;rsquo;s computers are at least 10 000 times
more powerful than the ones from back then. Likewise for ZKP, in theory they could be
used in many applications, but in practice they are extremely difficult
to build and exhibiy poor performance issues.&lt;/p>
&lt;p>It takes a lot of work and skill to properly use a ZKP system, similarly to how
it was tricky to use the first computers. At that time, due to their limited power and memory,
only very carefuly crafted software could run.&lt;/p>
&lt;p>The goal of this series of videos is to gain a moderate understanding of what ZKP
can do today and what they have in store for the near future.&lt;/p>
&lt;p>Let&amp;rsquo;s end this overview here. Next time, we will start looking at some of the usage of ZKP
that are already in production.&lt;/p></description></item><item><title>Docs: Hard Problems?</title><link>https://hhanh00.github.io/cryptoblog/docs/crypto/np/</link><pubDate>Sun, 13 Feb 2022 11:52:10 +0800</pubDate><guid>https://hhanh00.github.io/cryptoblog/docs/crypto/np/</guid><description>
&lt;p>Today we are going to discuss problem complexity.
We often hear &amp;ldquo;This problem is too hard for current
computer hardware, or this has an exponential growth&amp;hellip;&amp;rdquo;&lt;/p>
&lt;p>It is used so frequently that sometimes we lose track
of the real meaning of these terms, so today we want
to clarify definition because it is quite important
in the future discussions about algorithms.&lt;/p>
&lt;p>First of all, let&amp;rsquo;s talk about functions of one variable
$x$ over real numbers.&lt;/p>
&lt;p>For example, $f(x) = x^2+5$.&lt;/p>
&lt;p>We want to know how $f$ behaves as $x$ gets bigger.
That&amp;rsquo;s called the &amp;ldquo;asymptotic&amp;rdquo; behavior of $f$.&lt;/p>
&lt;p>In our example, $f$ grows indefinitively as $x$ grows, i.e
$f$ goes to the &lt;em>infinity&lt;/em>.
When something does that, we say it diverges.&lt;/p>
&lt;p>That&amp;rsquo;s the case for most of
the functions we will see, but the question is how fast
does $f$ grow?&lt;/p>
&lt;p>For that, we need other well known functions to compare $f$ with.&lt;/p>
&lt;h2 id="polynomials">Polynomials&lt;/h2>
&lt;p>One of the possible choices are functions of the form
$P_n(x) = x^n$ for some fixed value $n$ (it does not depend on $x$).&lt;/p>
&lt;p>Then we calculate $ f / P_n $ and we determine if the result still
grows to the infinity or it eventually stops.&lt;/p>
&lt;p>For $n=1$,
$$f / P_1 = (x^2+5)/x = x + 5/x $$&lt;/p>
&lt;p>Now the term $5/x$ will gets smaller and smaller as $x$ grows,
so the remaining interesting term is just $x$. That is still
going to the infinity. We need to increase $n$.&lt;/p>
&lt;p>For $n=2$, $$f / P_2 = (x^2+5)/x^2 = 1 + 5/x^2 $$&lt;/p>
&lt;p>$5/x^2$ gets smaller even faster so we can ignore it for
our asymptotic analysis and we can say that $f/P_2 &amp;lt;= 1 + 5$,
when $x &amp;gt;= 1$. $f/P_2$ does not diverge anymore.&lt;/p>
&lt;p>We can say $f$ behaves asymptotically like $x^2$.
And write it as&lt;/p>
&lt;p>$$ f = O(x^2) $$&lt;/p>
&lt;p>If we continue to increase $n$, then we can see that $F/P$
now, not only is bounded but is going to $0$.&lt;/p>
&lt;p>For example for $n=3$, $f/P_3 = 1/x + 5/x^3$ and this goes to $0$.&lt;/p>
&lt;p>When there is a value for $n$ such as $ f = O(x^n) $, $f$ is
said to have polynomial growth.&lt;/p>
&lt;p>In computer science, problems are classified by how many
steps it takes to find a solution.&lt;/p>
&lt;p>They come with a factor that represents their size.
For instance for the problem: &amp;ldquo;sort a list of numbers&amp;rdquo;. The
size parameter is &amp;ldquo;how long is the list?&amp;rdquo;.&lt;/p>
&lt;p>Let&amp;rsquo;s say the list has $n$ numbers, what&amp;rsquo;s the best algorithm?
Well, best is not very clear. Best by what? space used? time used?
in which case?
Then if we want a rough measure, we look at the asymptotic behavior.&lt;/p>
&lt;h2 id="bubble-sort">Bubble Sort&lt;/h2>
&lt;p>Bubble Sort is a simple sorting algorithm that works as follows:&lt;/p>
&lt;ul>
&lt;li>Go through the list, one by one, and swap two adjacent numbers
if they are out of order&lt;/li>
&lt;li>Repeat step 1 if at least two elements had to be swapped.&lt;/li>
&lt;/ul>
&lt;p>Example: with 1, 4, 2.&lt;/p>
&lt;ul>
&lt;li>First pass:
&lt;ul>
&lt;li>compare 1, 4: no need to swap&lt;/li>
&lt;li>compare 4, 2: swap. The list becomes 1, 2, 4&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Do a second pass because we had to swap something
&lt;ul>
&lt;li>compare 1, 2: no swap&lt;/li>
&lt;li>compare 2, 4: no swap&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Finish because there was no swap. The list is sorted: 1, 2, 4.&lt;/li>
&lt;/ul>
&lt;p>Let&amp;rsquo;s call $S(n)$ the number of steps that Bubble Sort takes to complete sorting a list of $n$ numbers.&lt;/p>
&lt;p>$S = O(n^2)$ in the worst case and $S = O(n)$ in the best case.&lt;/p>
&lt;p>It means that even if you give the best list of numbers to
the Bubble Sort algorith, it will take a number of steps that is
proportional to the length of the list. And if you give it the
worst list, then it will take a number of steps that is proportional
to the square of the number of elements.&lt;/p>
&lt;p>The best and worst lists depend on the algorithm but since in
many case we don&amp;rsquo;t get to choose it, we want to know how the
algorithm behaves in both cases.&lt;/p>
&lt;p>For Bubble Sort, the best case is if the list is already sorted.
A worst case is when the smallest element of the list is in the
last position. One pass only moves it by one step towards to head.&lt;/p>
&lt;h2 id="exponential-growth">Exponential Growth&lt;/h2>
&lt;p>Another class of functions is the exponential functions.&lt;/p>
&lt;p>Polynomial functions have the form $ x^n $ for some constant $n$.&lt;/p>
&lt;p>Exponential functions have the form $ n^x $ for some constant $n$.&lt;/p>
&lt;p>We just swapped the $x$ and the $n$. That makes a huge difference.&lt;/p>
&lt;p>For any value of $n &amp;gt; 1$, regardless how close it is to 1,
$n^x$ will eventually outgrow $x^n$. For example,&lt;/p>
&lt;p>you can choose n=1.1
in $x^n$ and n=10 in $x^n$, the former will outgrow the later.&lt;/p>
&lt;p>$1.1^{x} &amp;gt; x^{10}$ asymptotically (for values of $x$ large enough).
At around 700, the former overcomes the later and outpaces it very
quickly after.&lt;/p>
&lt;p>Incidentally, if you take a process that grows by a factor
at every step, the result is an exponential growth.&lt;/p>
&lt;p>Let&amp;rsquo;s say you have a disease that spreads to 10% more people
every month, it is $O(1.1^x)$&lt;/p>
&lt;h2 id="logarithmic-growth">Logarithmic Growth&lt;/h2>
&lt;p>Logarithmic is the inverse of exponential. If you have a function
$ y = O(n^x) $ then there is a $m$ such as $ x = \log_m(y) $&lt;/p>
&lt;p>Maybe an example will help. Let&amp;rsquo;s say $f(n)$ is the function that gives
the largest number that can be written with $n$ digits.&lt;/p>
&lt;p>\begin{align}
f(1) &amp;amp;= 9 \\
f(2) &amp;amp;= 99 \\
f(5) &amp;amp;= 99999 \\
\end{align}&lt;/p>
&lt;p>$f$ is not defined for values $x$ that are not integers. In other
words, $f(1.5)$ does not exist because $1.5$ digits does not mean
anything. But we can extend $f$ to values between integers.&lt;/p>
&lt;p>$$ g(x) = 10^x - 1 $$&lt;/p>
&lt;p>We can see that when x is in integer $f(x) = g(x)$.&lt;/p>
&lt;p>Now, the reverse of $f$ is &amp;ldquo;how many digits do I need to write
this number?&amp;rdquo;&lt;/p>
&lt;p>\begin{align}
f_i(9) &amp;amp;= 1 \\
f_i(99) &amp;amp;= 2 \\
f_i(99999) &amp;amp;= 5 \\
\end{align}&lt;/p>
&lt;p>$f_i$ still grows to the infinity but its growth is very slow.
When x is multiplied by $10$, $f$ only grows by $1$.&lt;/p>
&lt;p>Indeed $$f_i(x) = \left\lfloor \log_{10}(x+1) \right\rfloor $$&lt;/p>
&lt;p>These are the three major classes of comparison functions: Polynomial, Exponential and Logarithmic.&lt;/p>
&lt;p>But there are many others, we just don&amp;rsquo;t encounter them as often as
these three.&lt;/p>
&lt;h2 id="problem-complexity">Problem Complexity&lt;/h2>
&lt;p>Back to our original question: What is a hard problem?&lt;/p>
&lt;p>We can say: For this problem, the best algorithm we have will solve
it in $S(n)$ steps where $n$ is the &amp;ldquo;size&amp;rdquo;.&lt;/p>
&lt;p>For sorting a list, we have an algorithm (Bubble Sort) that does it in
$O(n^2)$ steps. But is it the best we can do?&lt;/p>
&lt;p>Turns out, no. We can do better. There are algorithms that
can sort a list in $O(n\log n)$ steps.&lt;/p>
&lt;p>Therefore sorting a list has $n\log n$ complexity. Because
$n\log n &amp;lt; n^2$, this problem has &lt;strong>polynomial complexity&lt;/strong>&lt;/p>
&lt;h2 id="solving-vs-verifying">Solving vs Verifying&lt;/h2>
&lt;p>So far we only considered the complexity of a solving algorithm.
If you are just interested in verifying a solution that was
given to you, the algorithm may be easier.&lt;/p>
&lt;p>In the sorting example, Bubble sort has $O(n^2)$ complexity but
to check if a list is sorted, you just need to go through the items
and make sure that every element is less than the next one.
That can be done in $O(n)$ steps.&lt;/p>
&lt;p>Problems that can be solved in polynomial time belong to the
class &lt;strong>P&lt;/strong>.&lt;/p>
&lt;p>Problems that can be verified in polynomial time and can be solved
by brute force (i.e. trying everything) belong to the class &lt;strong>NP&lt;/strong>.&lt;/p>
&lt;p>The hardest problems in the &lt;strong>NP&lt;/strong> class are called &lt;strong>NP-complete&lt;/strong>
problems.&lt;/p>
&lt;p>An NP-complete problem is such that &lt;em>any&lt;/em> NP problem can be transformed
to it in polynomial time. Unfortunately, there are many useful NP-complete
problems&lt;/p>
&lt;p>A popular example is the map coloring problem. Given a map of &amp;ldquo;countries&amp;rdquo;,
i.e. a 2-D set of connected regions, color each region so that
no two regions with the same color share a border. You may only use 4 colors.&lt;/p>
&lt;p>It is possible for any map but it is a NP-complete problem.&lt;/p>
&lt;h2 id="in-the-context-of-zk-proofs">In the context of ZK-Proofs&lt;/h2>
&lt;p>With ZK-Proofs, we have two parties involved. The Prover,
who has a solution and needs to produce a proof.
The verifiers who receives the proof and wants to verify it.&lt;/p>
&lt;p>Generally speaking, we accept that the prover has to do
additional work besides finding the solution in order to
calculate the proof but the verifier should do much less
work than solving the problem.&lt;/p></description></item><item><title>Docs: Applications of ZKP</title><link>https://hhanh00.github.io/cryptoblog/docs/zkp/apps/</link><pubDate>Thu, 10 Feb 2022 22:56:07 +0800</pubDate><guid>https://hhanh00.github.io/cryptoblog/docs/zkp/apps/</guid><description>
&lt;p>Today we look at some coins that use zk-proofs in
one way or another.&lt;/p>
&lt;p>But let&amp;rsquo;s start with what zk-proofs can do.&lt;/p>
&lt;p>First of all, functions has the same expressive power
than programs. In other words, any program can be
converted into a function. For example, if a program
processes financial transactions and tracks account balances,
it can be rewritten as a function that returns new account
balances given current balances and transaction data.&lt;/p>
&lt;p>Something like:&lt;/p>
&lt;p>$$ f(\mathrm{inputs}) = \mathrm{outputs} $$&lt;/p>
&lt;p>where outputs are the new state, usually public.
Some of the inputs are public, in this example it would be
the previous account balances and the rest of the inputs are
secret. $f$ is the ZKP function or sometimes it is called the
&lt;strong>statement&lt;/strong>.&lt;/p>
&lt;p>The ZK-Proof proves that you know the secret inputs
without giving any indication of what they are.&lt;/p>
&lt;p>Currently, cryptocurrencies use ZK-Proofs in a few
ways.&lt;/p>
&lt;h2 id="l2-zk-rollups">L2 ZK-Rollups&lt;/h2>
&lt;p>Previously, we talked about smart contracts. Ethereum is
famously the first cryptocurrency to introduce them. They
gained a lot of popularity and as a result the number of
transactions on the Ethereum blockchain grew significantly.
Along with it, transaction fees also increased. To a point
that it is no longer economical to directly call smart
contracts on Ethereum.&lt;/p>
&lt;p>A few teams work on reducing the strain on the blockchain (that&amp;rsquo;s layer 1)
by transmitting and executing transactions off chain (that&amp;rsquo;s layer 2).
ZKP are used in some of the Layer-2 solutions in order to
allow verification by smart contracts on the Layer 1. Ethereum has a few
of them: ZkSync, Aztec and Starkware.&lt;/p>
&lt;p>A normal rollup contract is deployed on Ethereum. It
verifies the validity of the zk proofs. Transactions
are processed off-chain.
Multiple transactions can be grouped, processed together
and submit a single zk proof on Ethereum.&lt;/p>
&lt;p>Recently Polygon announced Miden, a rollup project for
Ethereum VM.&lt;/p>
&lt;h2 id="privacy-coins">Privacy Coins&lt;/h2>
&lt;p>Privacy coins such as Zcash, Monero or Firo hide information
about transactions. Zcash encrypts all the amount and address
of the party involved. Monero mixes the real sender and receiver
with unrelated notes. In all cases, ZKP
are used to prove that the transaction remains valid.&lt;/p>
&lt;h2 id="succint-blockchain">Succint Blockchain&lt;/h2>
&lt;p>Finally, the last coin we are considering today is
Mina (Protocol). They use ZKP to enable a fixed size
blockchain. For any other coin, the blockchain is
formed by chaining a series of blocks (hence the name).
Even if the data that ends up on chain is kept to a minimum
with Layer 2 systems, by nature the blockchain
grows indefinitively as more and more blocks are produced.&lt;/p>
&lt;p>In Mina Protocol, the history, i.e. the previous blockchain
data serves as a hidden (or secret) input to the ZKP
function. Essentially, the statement means:
&amp;ldquo;I know a previous blockchain history and a series
of valid transactions, such as together they produce
this new block, and here&amp;rsquo;s the proof.&amp;rdquo;
Since the proof is part of the block, we have an instance
of a recursive ZKP because the ZKP is an input and
the function verifies its validity among other things.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Here you have it. A few concrete examples of usage
of ZKP in production blockchains. I am sure there are
going to be many more projects using ZKP. The proving
systems keep getting better and better, and they
become more accessible to the non-experts.&lt;/p></description></item><item><title>Docs: RSA - Our First Cryptosystem</title><link>https://hhanh00.github.io/cryptoblog/docs/crypto/rsa/</link><pubDate>Wed, 16 Feb 2022 14:27:51 +0800</pubDate><guid>https://hhanh00.github.io/cryptoblog/docs/crypto/rsa/</guid><description>
&lt;p>RSA is a public/private key cryptosystem
widely used currently.&lt;/p>
&lt;p>With the knowledge of finite fields we
acquired, we can understand how it works.&lt;/p>
&lt;p>We will not be able to prove that it is
safe against code breaking but generally
speaking, cryptoanalysis is beyond our scope.&lt;/p>
&lt;p>The first step of any cryptosystem is key generation.&lt;/p>
&lt;h2 id="key-generation">Key Generation&lt;/h2>
&lt;p>First you pick two prime numbers $p$ and $q$.
Normally these would be very large but we are
gonna use $p=3$ and $q=5$ for now.&lt;/p>
&lt;p>By the way, a prime number is an integer that
has &lt;em>exactly&lt;/em> two dividers: 1 and itself.&lt;/p>
&lt;p>For example, 2 is a prime number. So is 3, 5 and 7.
But 4 is not a prime number because $2 \times 2 = 4$.
1 is not a prime number because it has only one divider.&lt;/p>
&lt;p>Now calculate $$n = pq$$
$n = 3 \times 5 = 15$.&lt;/p>
&lt;p>Also calculate $$N = (p-1)(q-1)$$
$N = 2 \times 4 = 8$&lt;/p>
&lt;p>$N$ should be kept secret.&lt;/p>
&lt;p>Choose $e$ such as $e$ and $N$ don&amp;rsquo;t have any divider
in common.&lt;/p>
&lt;p>We pick $e = 3$&lt;/p>
&lt;p>Find the inverse of $e$ in $F_N$.&lt;/p>
&lt;p>$$ de = 1 \pmod N $$&lt;/p>
&lt;p>$d \times 3 = 1 \pmod 8 \implies d = 3$ because
$3 \times 3 = 9 = 1 \pmod 8$&lt;/p>
&lt;p>The public key is $(n, e)$, i.e $(15, 3)$
and the secret key is $d$.&lt;/p>
&lt;p>$N$, $p$ and $q$ can be
discarded.&lt;/p>
&lt;h2 id="encryption-and-decryption">Encryption and Decryption&lt;/h2>
&lt;p>You can encrypt using either $e$ or $d$
and decrypt with the other key. They can be
used interchangibly. We know $n$ because it is
part of the public key.&lt;/p>
&lt;p>Suppose we use $e$ (and $n$)&lt;/p>
&lt;p>To encrypt a message $m$, we calculate
$$ c = m^e \pmod n $$&lt;/p>
&lt;p>To decrypt the cypher $c$, we do the same but with
other other key
$$ m = c^d \pmod n $$&lt;/p>
&lt;p>Let&amp;rsquo;s say $m = 2$. $$ c = 2^3 = 8 \pmod{15} $$&lt;/p>
&lt;p>Then to decrypt, we calculate $c^3$ because $d=3$ (it&amp;rsquo;s
a coincidence that $d=e$).&lt;/p>
&lt;p>$$ 8^3 = 512 = 2 + 34 \times 15 = 2 \pmod{15} $$&lt;/p>
&lt;p>and we got back our message $m$.&lt;/p>
&lt;h2 id="proof-that-it-works">Proof that it works&lt;/h2>
&lt;p>Basically, we have to prove that $$ c ^ d = m \pmod n $$&lt;/p>
&lt;p>Put together,&lt;/p>
&lt;p>\begin{align}
c &amp;amp;= m^e \pmod n \\
m'&amp;amp;= c^d \\
m'&amp;amp;= c^d \\
&amp;amp;= (m^e)^d \\
&amp;amp;= m^{ed} \\
\end{align}&lt;/p>
&lt;p>and we want to prove that $m'=m$.&lt;/p>
&lt;p>To do so, we are going to use a theorem
called Fermat&amp;rsquo;s Little Theorem.&lt;/p>
&lt;p>For any $a$ and prime $p$,
$$ a^{p-1} = 1 \pmod p $$&lt;/p>
&lt;p>\begin{align}
m^{ed} &amp;amp;= m \pmod n \\
m^{ed} - m &amp;amp;= 0 \pmod n \\
&amp;amp;= kn \\
&amp;amp;= kpq \\
\end{align}&lt;/p>
&lt;p>\begin{align}
m^{ed} &amp;amp;= m \pmod p\quad \mathrm{and} \\
m^{ed} &amp;amp;= m \pmod q \\
\end{align}&lt;/p>
&lt;p>Let&amp;rsquo;s prove the first equation. The second has the
same proof since $p$ and $q$ have the same properties.&lt;/p>
&lt;p>If $m = 0 \pmod p$, $p$ divides $m$. $m^{ed}$ is
a multiple of $m$, therefore $p$ divides $m^{ed}$ too.
Then $m' = m^{ed} = 0 \pmod p$, and $m' = m$.&lt;/p>
&lt;p>If $m \ne 0 \pmod p$, $m^{ed} = m^{ed-1}m$.&lt;/p>
&lt;p>But $ed = 1 \pmod N$, therefore there is a $k$
such as $ed = kN + 1$&lt;/p>
&lt;p>$$m^{ed-1} = m^{kN} = m^{k(p-1)(q-1)} = {m^{p-1}}^{k(q-1)}$$&lt;/p>
&lt;p>$$ m^{p-1} = 1 \pmod p $$
So
$$ m^{ed-1} = {m^{p-1}}^{k(q-1)} = 1^{k(q-1)} = 1 \pmod p$$
Then
$$ m' = m^{ed} = m $$&lt;/p>
&lt;p>All that is left to do is to prove Fermat&amp;rsquo;s Little Theorem.&lt;/p>
&lt;h2 id="fermat-little-theorem-proof">Fermat Little Theorem Proof&lt;/h2>
&lt;p>Since $p$ is prime, $F_p$ is a field and ${1, 2, &amp;hellip;, p-1}$ form a group.&lt;/p>
&lt;p>We saw earlier that the only tricky part is to prove
that every element of $F^*_p$ has an inverse.
We&amp;rsquo;ll leave it aside because it is a bit more complex.&lt;/p>
&lt;p>Let&amp;rsquo;s consider ${1, a, a^2, &amp;hellip;}$ until it eventually
loops around (it has to because we have a finite
number of elements). The lowest $k$ such as $a^k = 1$
is called the order of $a$ relative to $\times$.&lt;/p>
&lt;p>We also so earlier that every sub group of a group
has a count of elements (cardinality)
that divides the cardinality of the group, here $p-1$.&lt;/p>
&lt;p>$$ a^{p-1} = a^{kn} = 1^n = 1 \pmod p $$&lt;/p>
&lt;h2 id="proof-that-f_p-is-a-group">Proof that $F^*_p$ is a group&lt;/h2>
&lt;p>We use Beyzout&amp;rsquo;s Lemma:&lt;/p>
&lt;p>Given $a$ and $b$ and their greatest common divider $d$,
there are $x$ and $y$ such as&lt;/p>
&lt;p>$$ ax + by = d $$&lt;/p>
&lt;p>$x$ and $y$ are positive or negative integers.&lt;/p>
&lt;p>The proof uses a common technique of algebra. Any non empty set of positive numbers has a smallest element.&lt;/p>
&lt;p>If we consider $S = \left\{ ax + by, \text{ such as } ax + by &amp;gt; 0 \right\}$, it is not empty (it contains $a$ and $b$) therefore it has a smallest element $d$.&lt;/p>
&lt;p>It turns out $d$ is the greatest common divider of $a$
and $b$.&lt;/p>
&lt;p>If we divide $a$ by $d$,&lt;/p>
&lt;p>$$ a = dq + r $$&lt;/p>
&lt;p>$q$ is the quotient and $r$ is the remainder.
$0 &amp;lt;= r &amp;lt; d$&lt;/p>
&lt;p>Then $r = a - dq = a - (ax+by)q = a(1-xq) -byq $&lt;/p>
&lt;p>$r$ has the form $ax + by$ and hence $r = ax+by \ge 0$
which means $ r \in S \cup \{0\} $.
We also know $r &amp;lt; d$. So $r$ cannot be in $S$ since
it&amp;rsquo;s smaller than the smallest element of $S$.
Then it must be that $r = 0$ and $a = dq$.&lt;/p>
&lt;p>$d$ divides $a$.&lt;/p>
&lt;p>Likewise, we can prove than $d$ divides $b$.
$d$ is a common divider of $a$ and $b$.&lt;/p>
&lt;p>Now we need to prove that it is the greatest common
divider.&lt;/p>
&lt;p>Let&amp;rsquo;s take any common divider $c$, $a = uc$ and $b = vc$&lt;/p>
&lt;p>Then $$d = ax + by = ucx + vcy = (ux + vy)c $$&lt;/p>
&lt;p>And $c$ divides $d$. Therefore $c \le d$.&lt;/p>
&lt;p>By applying this lemma to our case, we can say
that there are $x$ and $y$ such as&lt;/p>
&lt;p>$$ ax + py = 1 $$&lt;/p>
&lt;p>because $p$ is prime and the greatest common divider
of $a$ with a prime is 1.&lt;/p>
&lt;p>This is the same as saying&lt;/p>
&lt;p>$$ ax = 1 \pmod p $$&lt;/p>
&lt;p>And $x$ is the inverse of $a$.&lt;/p></description></item><item><title>Docs: Diffie Hellman</title><link>https://hhanh00.github.io/cryptoblog/docs/crypto/dh/</link><pubDate>Fri, 18 Feb 2022 11:49:09 +0800</pubDate><guid>https://hhanh00.github.io/cryptoblog/docs/crypto/dh/</guid><description>
&lt;p>Let&amp;rsquo;s continue our exploration of popular cryptosystems with another
widely used protocol: The Diffie Hellman (DH) key agreement protocol.&lt;/p>
&lt;p>When you connect to a &lt;code>https&lt;/code> website, you are using the DH protocol.
It is how your client, i.e. your web browser negociates a unique encryption
key with the server.&lt;/p>
&lt;p>We discussed RSA, a widely used public/private key crypto system and saw how it can
be used for encryption if you know the recipient&amp;rsquo;s public key.&lt;/p>
&lt;p>However, it is not the best algorithm for large documents because RSA is too slow
and impractical. Instead, a symetric encryption system
such as AES is used. We will discuss AES in a later post.&lt;/p>
&lt;p>Symetric encryption is much faster and easier to implement
than Public/Private Key cryptosystems. The later use an abundance of mathematics
whereas the former operates by shifting and moving bits around.&lt;/p>
&lt;p>All of that
can be done easily done in hardware (and in software too).&lt;/p>
&lt;p>Therefore, the stream of data exchanged between client and server is better encrypted
with AES than RSA.&lt;/p>
&lt;p>But there is a problem. How do the client and the server agree on a key without
communicating it beforehand?&lt;/p>
&lt;p>When you access a website for the first time,
obviously you never received any data before.
You can&amp;rsquo;t have a key. And if the server sends you a key, it would be in clear text
and subject to interception by a malicious third-party.&lt;/p>
&lt;p>How do you get a key when all your messages could be read during transport?&lt;/p>
&lt;p>Let&amp;rsquo;s imagine you have a noisy postman who reads
all of your mail. In this situation, how can you
establish a common secret with your destination.
So that you can start encrypting your messages.&lt;/p>
&lt;p>This is the goal of the Diffie Hellman protocol.&lt;/p>
&lt;p>Let&amp;rsquo;s review.&lt;/p>
&lt;p>We want to connect to a particular destination. Let&amp;rsquo;s say it&amp;rsquo;s a website at &lt;code>example.com&lt;/code>.
This website is registered and we can retrieve a public key. This key
represents its identity. We trust that in order to get this registration, they had to submit
some paperwork and the registrar made sure that they are who they claim.&lt;/p>
&lt;p>Now when I want to connect to &lt;code>example.com&lt;/code>, I want to be sure that I am connecting to
whoever has laid claim on that domain, i.e. whoever has registered.&lt;/p>
&lt;p>One way we could do this is to put the responsibility of key maintenance on the registrar.
When I want to connect, I ask the registrar for a unique key and it generates a unique key for me and &lt;code>example.com&lt;/code>. They send the key both to me
and &lt;code>example.com&lt;/code> over a long term secure channel.&lt;/p>
&lt;p>But, if every time someone wanted to connect
they had to get a new key from the registrar, it would create a lot of work for them.&lt;/p>
&lt;p>It&amp;rsquo;d better to have an algorithm where the &lt;em>only&lt;/em> piece of information we need from &lt;code>example.com&lt;/code>
is their public key. DH can do that.&lt;/p>
&lt;p>The mathematics needed to &lt;em>understand&lt;/em> DH are quite simple but again this is &lt;strong>not&lt;/strong>
going to prove the safety of DH. It is one thing to create a lock, it is much harder
to prove that the lock is unpickable.&lt;/p>
&lt;p>DH uses the same group we used for RSA: $(N_p^*, \times)$, i.e. the multiplicative
group of integers from $\{1, 2, &amp;hellip;, p-1\}$ where $p$ is a (large) prime number.&lt;/p>
&lt;p>If we pick a number $g$, we know from previous video that $\{1, g, g^2, g^3, &amp;hellip;, g^{p-1}\}$
forms a group.&lt;/p>
&lt;p>Basically, if we associate every number of $N_p^*$ by the formula:&lt;/p>
&lt;p>$$ x \mapsto g^x $$&lt;/p>
&lt;p>We &amp;ldquo;shuffled&amp;rdquo; the numbers of $N_p^*$.&lt;/p>
&lt;p>The most important thing to remember today is that this transformation is &lt;strong>very hard&lt;/strong>
to reverse (in most of the cases). Very hard as in: it&amp;rsquo;s gonna take a billion billion years for
relatively &amp;ldquo;short&amp;rdquo; $p$ (only a few hundred bits).&lt;/p>
&lt;p>This is called the &amp;ldquo;discrete logarithm problem&amp;rdquo;. The function above was an &amp;ldquo;exponentialization&amp;rdquo;
because the $x$ is in the exponent. Therefore the reverse is a logarithm. It&amp;rsquo;s a discrete
logarithm because we want the result to be an integer and not a real number.&lt;/p>
&lt;p>We will assume that solving the discrete logarithm problem is not efficient.&lt;/p>
&lt;p>Now let&amp;rsquo;s see how DH uses it.&lt;/p>
&lt;p>Both server and client agree on a value for $g$. In fact, &lt;em>everyone&lt;/em> agrees to use the same value
as it doesn&amp;rsquo;t matter what value it is.&lt;/p>
&lt;p>The server picks up a secret value $s$ and computes $x = g^s$. He registers $x$ so that anyone
who wants to communicate with it knows $x$. Yet, the value of $s$ remains private.&lt;/p>
&lt;p>Then the client picks up a new random key, anything in $N_p^*$. Let&amp;rsquo;s call it $s'$.&lt;/p>
&lt;p>He calculates $x' = g^{s'}$ and sends it to the server. This value will be different from any other
value.&lt;/p>
&lt;p>The server calculates $$S = x'^s = \left(g^{s'}\right)^s = g^{ss'}$$&lt;/p>
&lt;p>On his side, the client calculates
$$ C = x^{s'} = \left({g^s}\right)^{s'} = g^{ss'} $$&lt;/p>
&lt;p>And because $ss' = s&amp;rsquo;s$, $$C = S$$&lt;/p>
&lt;p>Now, they can use this value as their AES encryption key.&lt;/p>
&lt;p>We can notice that all messages sent between client and server are hiding their true value by putting
it in $g^x$. If someone intercepts them, he will not be able to extract the value of $x$ by virtue
of the &amp;ldquo;discrete logarithm problem&amp;rdquo;.&lt;/p>
&lt;p>An entire class of cryptosystems use this property. It&amp;rsquo;s called ElGamal encryption and we will
see it several times in future sessions.&lt;/p></description></item></channel></rss>